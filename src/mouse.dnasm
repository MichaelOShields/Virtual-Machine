.start
; .abs 0x3800


; init x, y as 64, 64
mov ri r1, 64
mov ri r2, 64


.const "multiplier", 5


call i on_sys

jmp i loop


loop:

    ; set to waiting:
    mov ri r0, 5 ; syscall waiting for input key
    sys ; next, should only run if there's available input i believe




    call i check_key

    call i on_sys

    jmp i loop



; functions:



check_key:


    mov ri r0, 1 ; check key syscall id
    sys


    cmp ri r0, 27
    jz i go_up
    cmp ri r0, 28
    jz i go_down
    cmp ri r0, 29
    jz i go_left
    cmp ri r0, 30
    jz i go_right

    ret
    ;jmp i after_key


no_move:
    ret


all_keys:
    call i off_sys
    ; sdb i 5
    ret




on_sys:
    push r r1
    push r r2
    push r r3

    
    call i convert_xy_call ; sets r3 to the correct val
    
    mul ri r3, 3 ; set to full brightness for negating
    andn mr r1, r3 ; erase current pixel that's there (may remove in future)
    div ri r3, 3
    
    mul ri r3, 3 ; set to full brightness to turn on the pixel
    or mr r1, r3
    
    
    
    
    pop r r3
    pop r r2
    pop r r1
    ret

off_sys:
    push r r1
    push r r2
    push r r3

    
    call i convert_xy_call ; sets r3 to the correct val
    
    mul ri r3, 3 ; set to full brightness for negating
    andn mr r1, r3 ; erase current pixel that's there
    div ri r3, 3
    
    
    
    
    pop r r3
    pop r r2
    pop r r1
    ret

go_right:
    call i all_keys
    add ri r1, multiplier
    
    cmp ri r1, 128
    jg i upper_bound_x
    ret

go_left:
    call i all_keys
    ; sub ri r2, 1
    ; jc i dec_r1

    sub ri r1, multiplier
    cmp ri r1, 128
    jg i lower_bound_x

    ret


go_up:
    call i all_keys
    sub ri r2, multiplier

    cmp ri r2, 21 ; if we go below 0, it wraps around to 255, so should check above 128
    jl i lower_bound_y

    ret


go_down:

    call i all_keys

    add ri r2, multiplier

    cmp ri r2, 127
    jg i upper_bound_y

    ret

lower_bound_y:
    mov ri r2, 21
    ret

upper_bound_y:
    mov ri r2, 127
    ret

lower_bound_x:
    mov ri r1, 1
    ret

upper_bound_x:
    mov ri r1, 128
    ret


convert_xy_call:
    push r r0
    push r r4
    push r r5
    push r r6
    push r r7
    call i convert_xy
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r0
    ret

.abs 0xD900
convert_xy:
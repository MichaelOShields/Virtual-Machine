.org 0x400




kernel:

    call i load_kregs ; works
    ; poll events
    call i check_input ; works


    ; main kernel code before returning to prog

    ; to run userprog, store kernel regs, store kernel stack ptr, set/pop user program stack ptr, run user program

    mov ri r0,255
    call i save_kregs
    call i save_ksp

    ; set usp

    ssp m 0x1300 ; should work, doesn't push/pop so i think stack is safe

    ; works so far

    ; load user regs
    call i load_uregs


    ; push user program ctr
    push m 0x130A ; big endian
    push m 0x130B

    ;dbg i 0

    ;pnk

    kret


    hlt




; functions:
halt:
    hlt

check_input:
    mov rm r2, 0x3400
    cmp ri r2, 1
    jz i update_input_buffer

    ret


update_input_buffer: ; last input stored at 0x12C4


    mov rm r2, 0x3401

    ; check if its esc
    cmp ri r2, 52
    jz i halt

    ; otherwise continue

    mov mr 0x87FF, r2 ; put into mem buffer

    ; moved last input to 0x12C4
    ret


save_ksp:
    gsp i 0x1250

    ret

save_usp:
    gsp i 0x1300
    ret

clear_regs:

    mov ri r0, 0
    mov ri r1, 0
    mov ri r2, 0
    mov ri r3, 0
    mov ri r4, 0
    mov ri r5, 0
    mov ri r6, 0
    mov ri r7, 0

    ret


load_kregs:
    
    mov rm r0, 0x1252 ; works
    mov rm r1, 0x1253
    mov rm r2, 0x1254
    mov rm r3, 0x1255
    mov rm r4, 0x1256
    mov rm r5, 0x1257
    mov rm r6, 0x1258
    mov rm r7, 0x1259

    ret

save_kregs:

    mov mr 0x1252, r0 ; works
    mov mr 0x1253, r1
    mov mr 0x1254, r2
    mov mr 0x1255, r3
    mov mr 0x1256, r4
    mov mr 0x1257, r5
    mov mr 0x1258, r6
    mov mr 0x1259, r7

    ret


load_syscall_regs: ; just bring back syscall-specific regs

    mov rm r0, 0x1252
    mov rm r1, 0x1253
    mov rm r2, 0x1254
    mov rm r4, 0x1255

    ret

load_uregs_after_syscall:

    mov rm r4, 0x1306
    mov rm r5, 0x1307
    mov rm r6, 0x1308
    mov rm r7, 0x1309

    ret

load_uregs:

    mov rm r0, 0x1302
    mov rm r1, 0x1303
    mov rm r2, 0x1304
    mov rm r3, 0x1305
    mov rm r4, 0x1306
    mov rm r5, 0x1307
    mov rm r6, 0x1308
    mov rm r7, 0x1309

    ret

save_uregs:

    mov mr 0x1302, r0
    mov mr 0x1303, r1
    mov mr 0x1304, r2
    mov mr 0x1305, r3
    mov mr 0x1306, r4
    mov mr 0x1307, r5
    mov mr 0x1308, r6
    mov mr 0x1309, r7

    ret






; KERNEL TRAP:

.org 0x1000 ; kernel trap





ktrap_catch:

    call i save_uregs


    ; upc is in stack

    pop r r0
    pop r r1

    ; store upc
    mov mr 0x130A, r0
    mov mr 0x130B, r1

    call i save_usp

    ssp m 0x1250 ; LOAD KSP

    mov rm r0, 0x1310 ; get reason

    ; diagnose cpuexit

    cmp ri r0, 0b0000 ; none, probably do nothing
    jz i resume_prog

    cmp ri r0, 0b0001 ; timer, return control to kernel
    jz i resume_prog


    cmp ri r0, 0b0010 ; halt, since it's a cpu exit we kill the application
    jz i kill_prog

    cmp ri r0, 0b0011 ; syscall
    jz i handle_syscall
    ; also, afterwards the jz's shouldn't ret, they should return to the kernel/program

    cmp ri r0, 0b0100 ; IllegalInstruction, should kill the program
    
    jz i kill_prog

    cmp ri r0, 0b0101 ; illegal mem access, just kill the program
    
    jz i kill_prog




    jmp i kernel




resume_prog_sys:
    ; set usp
    ssp m 0x1300

    ; load user regs
    call i load_uregs_after_syscall


    push m 0x130A
    push m 0x130B

    kret


resume_prog:
    ; set usp
    ssp m 0x1300

    ; load user regs
    call i load_uregs

    push m 0x130B
    push m 0x130A

    kret


handle_syscall:

    call i load_syscall_regs
    cmp ri r0, 0
    jz i resume_prog
    cmp ri r0, 1 ; getting key
    ; mov rm r0, 0x87FF ; no matter what we get the key?
    jz i get_key
    cmp ri r0, 2 ; draw a pixel in [r1:r2] as r3
    ; mov mr r1, r3
    jz i draw_pixel
    jmp i resume_prog_sys


get_key:
    mov rm r0, 0x87FF
    dbg i 41
    pnk
    ; now we're done w/ the syscall so jump to 
    jmp i resume_prog_sys

draw_pixel: ; draw pixel in [r1:r2] as r3
    mov mr r1, r3
    jmp i resume_prog_sys


kill_prog:
    dbg i 69
    hlt
    pnk


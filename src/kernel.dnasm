.org 0x400



kernel: ; round-robin scheduler

    ; call i load_kregs ; works
    ; poll events
    call i poll_input ; works


    ; main kernel code before returning to prog

    ; to run userprog, store kernel regs, store kernel stack ptr, set/pop user program stack ptr, run user program

    ; call i save_kregs ; do we even need this?



    ; pick next program:
    ; start w/ current task index:

    mov rm r0, 0x1260                               ; current task index stored in mem
    mov ri r4, hi(0x130E)                               ; user program #0 state/starting point to search
    mov ri r5, lo(0x130E)
    

    mov ri r3, 0x19                                 ; # bytes between programs; 0x19 * task_index gives us the task_index program state

    mul rr r3, r0 ; 0x19 * task_index gives us the task_index program state



    add rr r5, r3

    scheduler_loop:                     ; loop until we find a program that wants to run

    

        ; pnk

        cmp ri r0, 7
        jz i reset_r0

        mov ri r3, 0x19
        add rr r5, r3
        add ri r0, 1 ; keep current_task register up-to-date w/ indexed task state byte

        after_reset:

        mov rm r7, r4 ; check status of program
        cmp ri r7, 0
        
        jz i scheduler_loop

        cmp ri r7, 1 ; runnable

        jz i found_program

        cmp ri r7, 2
        jz i check_waiting

        check_rejection: ; if the waiting condition isn't satisfied yet

        jmp i scheduler_loop

        ; cmp ri r7, 1
        ; jz i found_program

        ; jmp i scheduler_loop ; need to cover more program states later, but this will do for now
    

    ; we've found a program that should be run:

    found_program:
    ; r0 contains the next task index
    mov mr 0x1260, r0 ; setting next task index in mem

    push r r1
    mov rm r1, 0x1260
    ; dbg r r1

    pop r r1

    ; now, let's load some stuff up:

    gsp i 0x1250 ; save KSP
    
    ; set USP
    mul ri r0, 0x19 ; can now do r0 + (whatever the starting byte is for whichever thing we need to check) and it gets us the right addr (i think)
    
    
    mov ri r4, 0x13
    ; high byte of program handling mem stuff. should add carry accounting later, but since
    ; everything is under 255 bytes here, we should be good for now.

    mov ri r5, 0x00 ; redundancy; init the low byte even though we're about to rewrite it


    ; now let's load up the stack ptr:
    mov ri r5, lo(0x1300) ; program 0 SP
    add rr r5, r0 ; get to current task index

    ssp m r4





    ; let's push the UPC now the SP is set:
    mov ri r4, hi(0x130F)
    mov ri r5, lo(0x130F)

    add rr r5, r0

    push m r4 ; big endian
    add ri r5, 1
    push m r4 ; low byte

    ; should work so far


    mov ri r4, hi(0x1302) ; addr of prog 0 regs
    mov ri r5, lo(0x1302)
    add rr r5, r0
    call i load_uregs ; this assumes [r4:r5] are initialized to 0x1302 + 0x19 * task_index


    ;dbg i 0

    ;pnk

    ; let's save r3, r4, and r5:
    push r r3
    push r r4
    push r r5

    ; let's set some flags before kretting:
    mov rm r3, 0x1260
    mul ri r3, 0x19

    mov ri r4, hi(0x130A)
    mov ri r5, lo(0x130A)
    add rr r5, r3
    
    sfls m r4

    pop r r5
    pop r r4
    pop r r3


    kret


    hlt




; functions:


check_waiting:
    

    ; if we're waiting, we know we're waiting for input (for now).
    ; push r r2
    ; call i poll_input
    ; pop r r2


    mov rm r6, 0x19FF

    cmp ri r6, 0
    jnz i check_acceptance ; found the program, let it run
    jz i check_rejection ; keep looking

    check_acceptance:

    mov ri r6, 1 ; set to runnable
    mov mr r4, r6 ; set the runnable state to runnable
    jmp i found_program



reset_r0:
    mov ri r0, 0
    mov ri r5, lo(0x130E)

    ; push r r0
    ; mov ri r0, 0
    ; mov mr 0x19FF, r0
    ; pop r r0

    ; push r r2
    ; call i poll_input
    ; pop r r2

    jmp i after_reset



halt:
    hlt

no_input:
    
    mov ri r2, 0
    mov mr 0x19FF, r2 ; key hasn't been pressed so we want to record that

    ret


poll_input:
    mov rm r2, 0x3400
    cmp ri r2, 1
    jz i update_input_buffer ; only if a new key's been pressed/is in the deque
    jnz i no_input

    ret


update_input_buffer:


    mov rm r2, 0x3401

    ; check if its esc
    ; cmp ri r2, 52
    ; jz i halt

    ; otherwise continue

    mov mr 0x19FF, r2 ; put into mem buffer


    ; moved last input to 0x12C4
    ret



clear_regs:

    mov ri r0, 0
    mov ri r1, 0
    mov ri r2, 0
    mov ri r3, 0
    mov ri r4, 0
    mov ri r5, 0
    mov ri r6, 0
    mov ri r7, 0

    ret


; load_kregs:
    
;     mov rm r0, 0x1252 ; works
;     mov rm r1, 0x1253
;     mov rm r2, 0x1254
;     mov rm r3, 0x1255
;     mov rm r4, 0x1256
;     mov rm r5, 0x1257
;     mov rm r6, 0x1258
;     mov rm r7, 0x1259

;     ret

; save_kregs:

;     mov mr 0x1252, r0 ; works
;     mov mr 0x1253, r1
;     mov mr 0x1254, r2
;     mov mr 0x1255, r3
;     mov mr 0x1256, r4
;     mov mr 0x1257, r5
;     mov mr 0x1258, r6
;     mov mr 0x1259, r7

;     ret


load_syscall_regs: ; just bring back syscall-specific regs

    ; let's set r0 to current_idx * 0x19
    mov rm r0, 0x1260
    mul ri r0, 0x19

    mov ri r6, hi(0x1302)
    mov ri r7, lo(0x1302)

    add rr r7, r0

    mov rm r0, r6
    add ri r7, 1

    mov rm r1, r6
    add ri r7, 1

    mov rm r2, r6
    add ri r7, 1

    mov rm r3, r6

    ; gets to this point

    ret

load_uregs_after_syscall:

    ; push syscall response, will pop it back afterwards:
    push r r0


    ; let's get r0 = current_task * 0x19
    mov rm r0, 0x1260
    mul ri r0, 0x19

    ; let's use r6:r7 as the mem addr and handle them later
    mov ri r6, hi(0x1302)
    mov ri r7, lo(0x1302)

    add rr r7, r0
    add ri r7, 1

    mov rm r1, r6
    add ri r7, 1

    mov rm r2, r6
    add ri r7, 1

    mov rm r3, r6
    add ri r7, 1

    mov rm r4, r6
    add ri r7, 1

    mov rm r5, r6
    add ri r7, 1

    ; handle r6 and r7, which are used:

    ; let's push r1 and r2
    push r r1
    push r r2

    mov rr r1, r6
    mov rr r2, r7


    mov rm r6, r1
    add ri r2, 1

    mov rm r7, r1

    ; now let's pop the previously-pushed registers (1 & 2)
    pop r r2
    pop r r1


    ; grab the syscall response we pushed earlier
    pop r r0
    ; dbg i 40
    ; pnk

    ret


load_uregs: ; assumes that r4:r5 is correctly set to 0x1300 + 0x19 * current_task_index

    mov rm r0, r4
    add ri r5, 1

    mov rm r1, r4
    add ri r5, 1

    mov rm r2, r4
    add ri r5, 1

    mov rm r3, r4
    add ri r5, 1

    push r r0 ; save it for later, but we have to overwrite r4:r5 rn and it's cooked
    push r r1

    mov rr r0, r4
    mov rr r1, r5

    mov rm r4, r0
    add ri r1, 1

    mov rm r5, r0
    add ri r1, 1

    mov rm r6, r0
    add ri r1, 1

    mov rm r7, r0
    add ri r1, 1

    pop r r1
    pop r r0 ; load previously-saved regs

    ret




save_uregs_ktrap:
    ; push uregs to kernel heap:
    mov mr 0x1800, r0
    mov mr 0x1801, r1
    mov mr 0x1802, r2
    mov mr 0x1803, r3
    mov mr 0x1804, r4
    mov mr 0x1805, r5
    mov mr 0x1806, r6
    mov mr 0x1807, r7

    mov rm r0, 0x1260 ; get current task index
    mul ri r0, 0x19 ; # of bytes per program state

    mov ri r4, hi(0x1302)
    mov ri r5, lo(0x1302)

    add rr r5, r0 ; initialize to program reg storage facility
    

    ; good so far
    
    mov rm r1, 0x1800 ; stored r0
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1801 ; stored r1
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1802
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1803
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1804
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1805
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1806
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1807
    mov mr r4, r1

    ret
    ; this function works!

;


save_flags_ktrap:
    ; save flags:
    mov ri r2, hi(0x130F) ; big endian
    mov ri r3, lo(0x130F)


    gfls m r2


; PIXEL FUNCTIONS:
; generally assume that x = r1, y = r2
; should call before_pixel_op beforehand (obv)
; should return 1 in r0 if it worked, 0 in r0 if it failed

; universal pixel op functions:

check_pixel_bounds: ; make sure we aren't doing anything illegal here


    ; compare r1 (x) to 127, jump if greater than to do nothing probably
    cmp ri r1, 128
    jg i failed_pixel_op

    ; same with r2 (y)
    cmp ri r2, 128
    jg i failed_pixel_op

    ret


before_pixel_op:
    call i check_pixel_bounds ; if this fails, it won't return; could that lead to a stack overflow/leak?

    ret



failed_pixel_op:
    ; if this is called, it means that the operation didn't work; hence, there are 2 bytes in the stack that aren't accounted for
    ; later, pop them? maybe


    ; pop bytes:
    pop r r6
    pop r r7
    ; will be deleted I think


    mov ri r0, 0 ; signal failed operation
    jmp i resume_prog_sys



; pixel op helper functions (should only be called after before_pixel_op):

; convert from x,y to vram addr:
convert_xy:
    ; assumes x = r1, y = r2
    ; pretty sure my math works out so no jump carries are needed, which should be more performant than just looping and spamming them
    ; will set r1 to high byte, r2 to low byte, puts the x,y pixel byte in r3

    ; move x and y to r4 and r5

    mov rr r4, r1 ; x is in r4 now
    mov rr r5, r2 ; y is in r5 now
    
    ; now initialize high and low byte
    mov ri r1, hi(0x2400) ; vram base pos
    mov ri r2, lo(0x2400)

    ; let's start with y:
    
    ; need to get y * 16, will put it in r6
    mov rr r6, r5
    ; mul ri r6, 16

    ; now, do high += (y * 16) / 8
    div ri r6, 16

    add rr r1, r6

    ; get original Y back for low += (y * 16) % 8
    mov rr r6, r5
    
    mul ri r6, 16

    ; mod ri r6, 8

    add rr r2, r6

    ; now let's do x, which is pretty simple: add x/8 to low byte

    mov rr r6, r4
    div ri r6, 8
    add rr r2, r6


    ; now let's handle r3:
    mov rr r6, r4 ; move x so we can perform ops on it




    

    ; now just do 0b1000_0000 >> (x % 8), then OR that into mem

    mov ri r3, 0b0000_0001

    mod ri r6, 8 ; modulo op, get remainder

    jz i grab_last_byte_bit

    shrw rr r3, r6

    grabbed_bit:


    ret

grab_last_byte_bit: ; this is when we reach a new byte, but need to get the pixel that's just to the left of the leftmost bit
    ; assumes r1:r2 are high and low
    sub ri r2, 1
    mov ri r3, 0b0000_0001
    jmp i grabbed_bit


go_down:
    add ri r2, 16
    jc i inc_r1
    ret

inc_r1:
    add ri r1, 1
    ret

next_letter_line:
    mov rm r7, r4
    mov mr r1, r7
    call i go_down
    add ri r5, 1
    ret


; pixel ops:


write_letter: ; starts at 0x1200; x is r1, y is r2, letter ID is r3
    call i before_pixel_op

    ; in addition to before_pixel_op bound checks:
    ; letters are 5x7, so ensure that they won't write into illegal mem:
    
    ; compare r1 (x) to 127, jump if greater than to do nothing probably
    cmp ri r1, 123  ; 128-5 = 123
    jg i failed_pixel_op

    cmp ri r1, 5
    jl i failed_pixel_op

    ; same with r2 (y)
    cmp ri r2, 121 ; 128-7 = 121
    jg i failed_pixel_op

    ; now the main function:

    push r r3 ; save r3 b/c convert_xy tramples it

    ; go 1 line lower
    add ri r2, 1

    call i convert_xy

    pop r r3


    ; start writing:
    mov ri r4, hi(0x1200)
    mov ri r5, lo(0x1200)

    mul ri r3, 7
    add rr r5, r3           ; get ptr aligned w/ correct letter


    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line

    jmp i resume_prog_sys


pixel_on:

    call i before_pixel_op

    
    
    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel

    
    ; OR operation - only turn on the specific pixel specified by 8 - (x % 8)

    or rm r3, r1 ; get actual pixels in mem & OR them
    

    ; put r7 (final byte) into mem
    mov mr r1, r3


    jmp i resume_prog_sys




pixel_off:

    call i before_pixel_op

    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel

    ; OR operation - only turn on the specific pixel specified by 8 - (x % 8)
    xor rm r3, r1 ; get actual pixels in mem & OR them

    ; put r7 (final byte) into mem
    mov mr r1, r3

    jmp i resume_prog_sys





; KERNEL TRAP:

.org 0x1000 ; kernel trap





ktrap_catch:

    gfls i 0x1808 ; temp store flags in heap, later MUST return them

    
    call i save_uregs_ktrap

    mov rm r0, 0x1260
    mul ri r0, 0x19
    ; now task_index * 0x19 is stored in r0


    ; upc is in stack

    pop r r6
    pop r r7

    ; works so far; in user testing rn, 2 datapts remain on the stack (the ret addr)


    ; store upc: / works
    mov ri r2, hi(0x130F) ; big endian
    mov ri r3, lo(0x130F)
    
    add rr r3, r0 ; get low byte/index of UPC tracker

    mov mr r2, r6

    add ri r3, 1

    mov mr r2, r7

    ; should be good so far
    


    ; save USP:

    mov rm r0, 0x1260
    mul ri r0, 0x19

    mov ri r2, hi(0x1300)
    mov ri r3, lo(0x1300)
    add rr r3, r0

    gsp m r2

    ssp m 0x1250 ; LOAD KSP

    ; save flags previously stored in 0x1808 (heap)
    ; use r2,3,4,5

    mov rm r2, 0x1808
    mov rm r3, 0x1809
    mov rm r4, 0x180A
    mov rm r5, 0x180B

    mov ri r6, hi(0x130A)
    mov ri r7, lo(0x130A)
    mov rm r0, 0x1260
    mul ri r0, 0x19
    add rr r7, r0


    mov mr r6, r2
    add ri r7, 1
    mov mr r6, r3
    add ri r7, 1
    mov mr r6, r4
    add ri r7, 1
    mov mr r6, r5



    

    mov rm r7, 0x125A ; get reason

    

    ; diagnose cpuexit

    cmp ri r7, 0b0000 ; none, probably do nothing
    jz i resume_prog

    cmp ri r7, 0b0001 ; timer, return control to kernel
    jz i resume_prog


    cmp ri r7, 0b0010 ; halt, since it's a cpu exit we kill the application
    jz i apoptosis ; "kill the program"

    cmp ri r7, 0b0011 ; syscall / works so far
    jz i handle_syscall


    cmp ri r7, 0b0100 ; IllegalInstruction, should kill the program
    
    jz i apoptosis

    cmp ri r7, 0b0101 ; illegal mem access, just kill the program
    
    jz i apoptosis




    jmp i kernel




resume_prog_sys:
    ; let's move r0, r1, and r2 onto the heap so we can restore them later:
    mov mr 0x1800, r0
    ; mov mr 0x1801, r1
    ; mov mr 0x1802, r2
    ; good so far

    ; now let's set r0 to prog_idx * 0x19
    mov rm r0, 0x1260
    mul ri r0, 0x19

    mov ri r1, hi(0x1300)
    mov ri r2, lo(0x1300)
    add rr r2, r0

    ssp m r1


    ; the last thing we need to do with the registers is to push the UPC (big-endian)
    mov ri r1, hi(0x130F)
    mov ri r2, lo(0x130F)
    add rr r2, r0

    push m r1 ; hi byte
    add ri r2, 1
    push m r1 ; lo byte
    
    ; now let's return the registers:
    mov rm r0, 0x1800
    ; mov rm r1, 0x1801
    ; mov rm r2, 0x1802

    ; load user regs
    call i load_uregs_after_syscall


    kret


resume_prog:
    ; set usp
    ; mov ri r2, hi(0x1300)
    ; mov ri r3, lo(0x1300)
    ; add rr r3, r0

    ; ssp m r2

    ; ; push UPC (big endian) for KRET:
    ; mov ri r2, hi(0x130F)
    ; mov ri r3, lo(0x130F)
    ; add rr r3, r0

    ; push m r2
    ; add ri r3, 1
    ; push m r2

    ; ; load user regs
    ; mov ri r4, hi(0x1302)
    ; mov ri r5, lo(0x1302)
    ; add rr r5, r0
    ; call i load_uregs ; assumes [r4:r5] is alr correct

    ; kret

    jmp i kernel


handle_syscall:

    call i load_syscall_regs ; get registers saved from user, but only those relevant to the syscall

    cmp ri r0, 0 ; no syscall, just return

    jz i resume_prog


    cmp ri r0, 1 ; see if there's a new input, if so return it

    jz i get_key


    cmp ri r0, 2 ; turn on pixel with x = r1 and y = r2

    jz i pixel_on

    cmp ri r0, 3 ; turn off pixel with x = r1 and y = r2
    jz i pixel_off

    cmp ri r0, 4 ; write letter at (x: r1, y: r2) specified by r3
    jz i write_letter

    cmp ri r0, 5 ; change to waiting for input (input "mode" specified in r3)
    jz i set_waiting_input

    
    jmp i resume_prog_sys


set_waiting_input:
    mov rm r5, 0x1260
    mul ri r5, 0x19

    mov ri r6, hi(0x130E) ; byte specifying runnable state; set to 2
    mov ri r7, lo(0x130E)
    
    add rr r7, r5
    ; input mode specified in r3

    mov ri r4, 2 ; "waiting" runnable state
    mov mr r6, r4 ; set to waiting state

    mov ri r6, hi(0x1311) ; byte detailing waiting reason
    mov ri r7, lo(0x1311)
    add rr r7, r5

    push r r0
    mov ri r0, 1
    mov mr r6, r0 ; later will add multiple waiting modes
    pop r r0

    ; have already saved everything, but we probably want to go to the next program in the scheduler:
    jmp i kernel




get_key:
    ; call i poll_input
    mov rm r0, 0x19FF
    
    ; push r r0
    ; mov ri r0, 0
    ; mov mr 0x19FF, r0
    ; pop r r0
    ; now we're done w/ the syscall so jump to 
    jmp i resume_prog_sys
;


apoptosis: ; "progammed cell death" just kill the program
    dbg i 69
    hlt
    pnk









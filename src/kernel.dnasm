.start



kernel:



    ; call i load_kregs ; works
    ; poll events
    call i poll_input ; works


    ; main kernel code before returning to prog

    ; to run userprog, store kernel regs, store kernel stack ptr, set/pop user program stack ptr, run user program

    ; call i save_kregs ; do we even need this?



    ; pick next program:
    ; start w/ current task index:

    mov rm r0, 0x12C8                               ; current task index stored in mem
    mov ri r4, hi(0x130E)                               ; user program #0 state/starting point to search
    mov ri r5, lo(0x130E)


    mov ri r3, 0x19                                 ; # bytes between programs; 0x19 * task_index gives us the task_index program state

    mul rr r3, r0 ; 0x19 * task_index gives us the task_index program state



    add rr r5, r3

    scheduler_loop:                     ; loop until we find a program that wants to run

    

        ; pnk

        mov ri r3, 0x19
        add rr r5, r3
        add ri r0, 1 ; keep current_task register up-to-date w/ indexed task state byte

        cmp ri r0, 7
        jz i reset_r0

        after_reset:

        mov rm r7, r4 ; check status of program
        cmp ri r7, 0
        
        jz i scheduler_loop

        cmp ri r7, 1 ; runnable

        jz i found_program

        cmp ri r7, 2
        jz i check_waiting

        check_rejection: ; if the waiting condition isn't satisfied yet

        jmp i scheduler_loop

        ; cmp ri r7, 1
        ; jz i found_program

        ; jmp i scheduler_loop ; need to cover more program states later, but this will do for now
    

    ; we've found a program that should be run:

    found_program:
    ; r0 contains the next task index
    mov mr 0x12C8, r0 ; setting next task index in mem

    ; now, let's load some stuff up:

    gsp i 0x12C5 ; save KSP
    
    ; set USP
    mul ri r0, 0x19 ; can now do r0 + (whatever the starting byte is for whichever thing we need to check) and it gets us the right addr (i think)
    
    
    mov ri r4, 0x13
    ; high byte of program handling mem stuff. should add carry accounting later, but since
    ; everything is under 255 bytes here, we should be good for now.

    mov ri r5, 0x00 ; redundancy; init the low byte even though we're about to rewrite it


    ; now let's load up the stack ptr:
    mov ri r5, lo(0x1300) ; program 0 SP
    add rr r5, r0 ; get to current task index

    ssp m r4





    ; let's push the UPC now the SP is set:
    mov ri r4, hi(0x130F)
    mov ri r5, lo(0x130F)

    add rr r5, r0

    push m r4 ; big endian
    add ri r5, 1
    push m r4 ; low byte

    ; should work so far


    mov ri r4, hi(0x1302) ; addr of prog 0 regs
    mov ri r5, lo(0x1302)
    add rr r5, r0
    call i load_uregs ; this assumes [r4:r5] are initialized to 0x1302 + 0x19 * task_index


    ;dbg i 0

    ;pnk

    ; let's save r3, r4, and r5:
    push r r3
    push r r4
    push r r5

    ; let's set some flags before kretting:
    mov rm r3, 0x12C8
    mul ri r3, 0x19

    mov ri r4, hi(0x130A)
    mov ri r5, lo(0x130A)
    add rr r5, r3
    
    sfls m r4

    pop r r5
    pop r r4
    pop r r3


    kret


    hlt




; functions:


check_waiting:
    

    ; if we're waiting, we know we're waiting for input (for now).
    ; push r r2
    ; call i poll_input
    ; pop r r2


    mov rm r6, 0x17FF

    cmp ri r6, 0
    jnz i check_acceptance ; found the program, let it run
    jz i check_rejection ; keep looking

    check_acceptance:

    mov ri r6, 1 ; set to runnable
    mov mr r4, r6 ; set the runnable state to runnable
    jmp i found_program



reset_r0:
    mov ri r0, 0
    mov ri r5, lo(0x130E)

    mov mr 0x17FF, r0


    push r r2
    call i poll_input
    pop r r2

    ; push r r0
    ; mov ri r0, 0
    ; mov mr 0x17FF, r0
    ; pop r r0

    ; push r r2
    ; call i poll_input
    ; pop r r2

    jmp i after_reset



halt:
    hlt

no_input:
    
    ; mov ri r2, 0
    ; mov mr 0x17FF, r2 ; key hasn't been pressed so we want to record that

    ret


poll_input:
    mov rm r2, 0x3400
    cmp ri r2, 1
    jz i update_input_buffer ; only if a new key's been pressed/is in the deque
    jnz i no_input

    ret


update_input_buffer:

    


    mov rm r2, 0x3401

    ; check if its esc
    ; cmp ri r2, 52
    ; jz i halt

    ; otherwise continue

    mov mr 0x17FF, r2 ; put into mem buffer


    ; moved last input to 0x12C4
    ret



clear_regs:

    mov ri r0, 0
    mov ri r1, 0
    mov ri r2, 0
    mov ri r3, 0
    mov ri r4, 0
    mov ri r5, 0
    mov ri r6, 0
    mov ri r7, 0

    ret


; load_kregs:
    
;     mov rm r0, 0x1252 ; works
;     mov rm r1, 0x1253
;     mov rm r2, 0x1254
;     mov rm r3, 0x1255
;     mov rm r4, 0x1256
;     mov rm r5, 0x1257
;     mov rm r6, 0x1258
;     mov rm r7, 0x1259

;     ret

; save_kregs:

;     mov mr 0x1252, r0 ; works
;     mov mr 0x1253, r1
;     mov mr 0x1254, r2
;     mov mr 0x1255, r3
;     mov mr 0x1256, r4
;     mov mr 0x1257, r5
;     mov mr 0x1258, r6
;     mov mr 0x1259, r7

;     ret


load_syscall_regs: ; just bring back syscall-specific regs

    ; let's set r0 to current_idx * 0x19
    mov rm r0, 0x12C8
    mul ri r0, 0x19

    mov ri r6, hi(0x1302)
    mov ri r7, lo(0x1302)

    add rr r7, r0

    mov rm r0, r6
    add ri r7, 1

    mov rm r1, r6
    add ri r7, 1

    mov rm r2, r6
    add ri r7, 1

    mov rm r3, r6

    ; gets to this point

    ret

load_uregs_after_syscall:

    ; push syscall response, will pop it back afterwards:
    push r r0


    ; let's get r0 = current_task * 0x19
    mov rm r0, 0x12C8
    mul ri r0, 0x19

    ; let's use r6:r7 as the mem addr and handle them later
    mov ri r6, hi(0x1302)
    mov ri r7, lo(0x1302)

    add rr r7, r0
    add ri r7, 1

    mov rm r1, r6
    add ri r7, 1

    mov rm r2, r6
    add ri r7, 1

    mov rm r3, r6
    add ri r7, 1

    mov rm r4, r6
    add ri r7, 1

    mov rm r5, r6
    add ri r7, 1

    ; handle r6 and r7, which are used:

    ; let's push r1 and r2
    push r r1
    push r r2

    mov rr r1, r6
    mov rr r2, r7


    mov rm r6, r1
    add ri r2, 1

    mov rm r7, r1

    ; now let's pop the previously-pushed registers (1 & 2)
    pop r r2
    pop r r1


    ; grab the syscall response we pushed earlier
    pop r r0
    ; dbg i 40
    ; pnk

    ret


load_uregs: ; assumes that r4:r5 is correctly set to 0x1300 + 0x19 * current_task_index

    mov rm r0, r4
    add ri r5, 1

    mov rm r1, r4
    add ri r5, 1

    mov rm r2, r4
    add ri r5, 1

    mov rm r3, r4
    add ri r5, 1

    push r r0 ; save it for later, but we have to overwrite r4:r5 rn and it's cooked
    push r r1

    mov rr r0, r4
    mov rr r1, r5

    mov rm r4, r0
    add ri r1, 1

    mov rm r5, r0
    add ri r1, 1

    mov rm r6, r0
    add ri r1, 1

    mov rm r7, r0
    add ri r1, 1

    pop r r1
    pop r r0 ; load previously-saved regs

    ret




save_uregs_ktrap:
    ; push uregs to kernel heap:
    mov mr 0x1800, r0
    mov mr 0x1801, r1
    mov mr 0x1802, r2
    mov mr 0x1803, r3
    mov mr 0x1804, r4
    mov mr 0x1805, r5
    mov mr 0x1806, r6
    mov mr 0x1807, r7

    mov rm r0, 0x12C8 ; get current task index
    mul ri r0, 0x19 ; # of bytes per program state

    mov ri r4, hi(0x1302)
    mov ri r5, lo(0x1302)

    add rr r5, r0 ; initialize to program reg storage facility
    

    ; good so far
    
    mov rm r1, 0x1800 ; stored r0
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1801 ; stored r1
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1802
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1803
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1804
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1805
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1806
    mov mr r4, r1
    add ri r5, 1

    mov rm r1, 0x1807
    mov mr r4, r1

    ret
    ; this function works!

;


save_flags_ktrap:
    ; save flags:
    mov ri r2, hi(0x130F) ; big endian
    mov ri r3, lo(0x130F)


    gfls m r2


; PIXEL FUNCTIONS:
; generally assume that x = r1, y = r2
; should call before_pixel_op beforehand (obv)
; should return 1 in r0 if it worked, 0 in r0 if it failed

; universal pixel op functions:

check_pixel_bounds: ; make sure we aren't doing anything illegal here


    ; compare r1 (x) to 127, jump if greater than to do nothing probably
    cmp ri r1, 128
    jg i failed_pixel_op

    ; same with r2 (y)
    cmp ri r2, 128
    jg i failed_pixel_op

    ret


before_pixel_op:
    call i check_pixel_bounds ; if this fails, it won't return; could that lead to a stack overflow/leak?

    ret



failed_pixel_op:
    ; if this is called, it means that the operation didn't work; hence, there are 2 bytes in the stack that aren't accounted for
    ; later, pop them? maybe


    ; pop bytes:
    pop r r6
    pop r r7
    ; will be deleted I think


    mov ri r0, 0 ; signal failed operation

    jmp i resume_prog_sys



; pixel op helper functions (should only be called after before_pixel_op):

; convert from x,y to vram addr:
convert_xy:
    ; assumes x = r1, y = r2
    ; pretty sure my math works out so no jump carries are needed, which should be more performant than just looping and spamming them
    ; will set r1 to high byte, r2 to low byte, puts the x,y pixel byte in r3

    ; move x and y to r4 and r5

    mov rr r4, r1 ; x is in r4 now
    mov rr r5, r2 ; y is in r5 now

    ; now initialize high and low byte
    mov ri r1, hi(0x2400) ; vram base pos
    mov ri r2, lo(0x2400)

    ; 00 00 00 00
    ; 00 00 00 00
    ; 00 00 00 00
    ; 00 00 00 00

    ; y:
    mov rr r6, r5
    div ri r6, 8
    add rr r1, r6

    mov rr r6, r5
    mod ri r6, 8
    mul ri r6, 32
    add rr r2, r6



    ; x:
    mov rr r6, r4
    div ri r6, 4

    add rr r2, r6


    ; now for the individual pixel:
    mov rr r6, r4

    mod ri r6, 4

    jz i grab_last_byte_bit

    mov ri r3, 0b0000_0001 ; x3 for full brightness, x2 for 66%, x1 for 33%

    mul ri r6, 2


    shrw rr r3, r6

    grabbed_bit:


    ret

dec_r1:
    sub ri r1, 1
    ret

dec_r2:
    sub ri r2, 1
    jc i dec_r1
    ret


grab_last_byte_bit: ; this is when we reach a new byte, but need to get the pixel that's just to the left of the leftmost bit
    ; assumes r1:r2 are high and low
    call i dec_r2
    mov ri r3, 0b0000_0001
    jmp i grabbed_bit


go_down:
    add ri r2, 32
    jc i inc_r1
    ret

inc_r1:
    add ri r1, 1
    ret

next_byte:
    add ri r5, 1
    ret

letter_byte:
    mov rm r7, r4
    mov mr r1, r7

    call i next_byte
    
    ; mov rm r7, r4
    ; mov mr r1, r7

    ret


inplace_letter_byte:
    mov rm r7, r4
    or mr r1, r7

    call i next_byte
    
    ; mov rm r7, r4
    ; or mr r1, r7

    ret

    

next_writing_line: ; this is wr
    call i letter_byte

    call i go_down

    ; call i next_byte

    ret

next_inplace_writing_line:
    call i inplace_letter_byte

    call i go_down

    ; call i next_byte
    ret


; pixel ops:

get_current_line: ; assumes r4:r5 is writing line, puts it into r3
    mov rm r3, r4
    ret

inc_r1_byte:
    add ri r1, 1
    jc i inc_r0
    ret

inc_r0:
    add ri r0, 1
    ret

next_line:
    ; need to do some fancy stuff
    call i get_current_line ; get current letter line

    ; r6, r7 are free.
    ; r6 = first byte of the line
    ; r7 = second byte of the line

    ; let's start with the first 4 bits (msb-wise):
    shr ri r3, 4 ; isolate first 4 bits of letter line

    mov ri r6, 0
    mov ri r7, 0

    ; for first bit (msb), need to figure out if it's on:
    first_bit1:
    and ri r3, 0b0000_1000
    cmp ri r3, 8
    jnz i second_bit1 ; skip this part if it isn't "on"

    add ri r6, 0b1100_0000

    second_bit1:

    call i get_current_line
    shr ri r3, 4
    
    and ri r3, 0b0000_0100
    cmp ri r3, 4
    jnz i third_bit1

    add ri r6, 0b0011_0000

    third_bit1:

    call i get_current_line
    shr ri r3, 4
    
    and ri r3, 0b0000_0010
    cmp ri r3, 2
    jnz i fourth_bit1

    add ri r6, 0b0000_1100

    fourth_bit1:

    call i get_current_line
    shr ri r3, 4
    
    and ri r3, 0b0000_0001
    cmp ri r3, 1
    jnz i second_byte

    add ri r6, 0b0000_0011

    second_byte:

    call i get_current_line
    ; no need to shr this time

    first_bit2:
    and ri r3, 0b0000_1000
    cmp ri r3, 8
    jnz i second_bit2 ; skip this part if it isn't "on"

    add ri r7, 0b1100_0000

    second_bit2:

    call i get_current_line
    
    and ri r3, 0b0000_0100
    cmp ri r3, 4
    jnz i third_bit2

    add ri r7, 0b0011_0000

    third_bit2:

    call i get_current_line
    
    and ri r3, 0b0000_0010
    cmp ri r3, 2
    jnz i fourth_bit2

    add ri r7, 0b0000_1100

    fourth_bit2:

    call i get_current_line
    
    and ri r3, 0b0000_0001
    cmp ri r3, 1
    jnz i done_line

    add ri r7, 0b0000_0011


    done_line:
    ret

inc_r4:
    add ri r4, 1
    ret

inc_r5:
    add ri r5, 1
    jc i inc_r4
    ret

go_down_r1:
    add ri r1, 31
    jc i inc_r0
    ret

next_line_writing:
    call i next_line
    mov mr r0, r6
    call i inc_r1_byte
    mov mr r0, r7
    call i inc_r5
    call i go_down_r1
    ret

next_inplace_line_writing:
    call i next_line
    or mr r0, r6
    call i inc_r1_byte
    or mr r0, r7
    call i inc_r5
    call i go_down_r1
    ret


write_letter:
    call i before_pixel_op

    push r r3 ; contains letter ID
    call i convert_xy
    pop r r3


    mov rr r0, r1
    mov rr r1, r2
    ; r0:r1 contains the byte we're modifying

    ; now, r4-7 are free
    mov ri r4, hi(0xD800)
    mov ri r5, lo(0xD800)
    mul ri r3, 7
    add rr r5, r3 ; align font ptr, also frees up r3

    ; dbg m r4

    call i next_line_writing
    call i next_line_writing
    call i next_line_writing
    call i next_line_writing
    call i next_line_writing
    call i next_line_writing
    call i next_line_writing

    jmp i resume_prog_sys

write_letter_in_place:
    call i before_pixel_op

    push r r3 ; contains letter ID
    call i convert_xy
    pop r r3


    mov rr r0, r1
    mov rr r1, r2
    ; r0:r1 contains the byte we're modifying

    ; now, r4-7 are free
    mov ri r4, hi(0xD800)
    mov ri r5, lo(0xD800)
    mul ri r3, 7
    add rr r5, r3 ; align font ptr, also frees up r3

    ; dbg m r4

    call i next_inplace_line_writing
    call i next_inplace_line_writing
    call i next_inplace_line_writing
    call i next_inplace_line_writing
    call i next_inplace_line_writing
    call i next_inplace_line_writing
    call i next_inplace_line_writing

    jmp i resume_prog_sys


pixel_on_33:

    call i before_pixel_op

    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel
    
    ; OR operation - only turn on the specific pixel


    ; put r7 (final byte) into mem
    mul ri r3, 3
    andn mr r1, r3
    div ri r3, 3

    or mr r1, r3

    jmp i resume_prog_sys


pixel_on_66:

    call i before_pixel_op
    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel

    mul ri r3, 3
    andn mr r1, r3
    div ri r3, 3

    mul ri r3, 2


    
    or mr r1, r3


    jmp i resume_prog_sys


pixel_on_full:


    call i before_pixel_op
    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel

    mul ri r3, 3
    andn mr r1, r3
    div ri r3, 3


    mul ri r3, 3
    ; OR operation - only turn on the specific pixel
    ; put r7 (final byte) into mem
    or mr r1, r3


    jmp i resume_prog_sys

pixel_off:

    call i before_pixel_op

    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel


    ; put r7 (final byte) into mem
    mul ri r3, 3
    andn mr r1, r3

    jmp i resume_prog_sys





; KERNEL TRAP:

.abs 0x1000 ; kernel trap





ktrap_catch:

    gfls i 0x1808 ; temp store flags in heap, later MUST return them

    
    call i save_uregs_ktrap

    mov rm r0, 0x12C8
    mul ri r0, 0x19
    ; now task_index * 0x19 is stored in r0


    ; upc is in stack

    pop r r6
    pop r r7

    ; works so far; in user testing rn, 2 datapts remain on the stack (the ret addr)


    ; store upc: / works
    mov ri r2, hi(0x130F) ; big endian
    mov ri r3, lo(0x130F)
    
    add rr r3, r0 ; get low byte/index of UPC tracker

    mov mr r2, r6

    add ri r3, 1

    mov mr r2, r7

    ; should be good so far
    


    ; save USP:

    mov rm r0, 0x12C8
    mul ri r0, 0x19

    mov ri r2, hi(0x1300)
    mov ri r3, lo(0x1300)
    add rr r3, r0

    gsp m r2

    ssp m 0x12C5 ; LOAD KSP

    ; save flags previously stored in 0x1808 (heap)
    ; use r2,3,4,5

    mov rm r2, 0x1808
    mov rm r3, 0x1809
    mov rm r4, 0x180A
    mov rm r5, 0x180B

    mov ri r6, hi(0x130A)
    mov ri r7, lo(0x130A)
    mov rm r0, 0x12C8
    mul ri r0, 0x19
    add rr r7, r0


    mov mr r6, r2
    add ri r7, 1
    mov mr r6, r3
    add ri r7, 1
    mov mr r6, r4
    add ri r7, 1
    mov mr r6, r5



    

    mov rm r7, 0x12C7 ; get reason

    

    ; diagnose cpuexit

    cmp ri r7, 0b0000 ; none, probably do nothing
    jz i kernel

    cmp ri r7, 0b0001 ; timer, return control to kernel
    jz i kernel


    cmp ri r7, 0b0010 ; halt, since it's a cpu exit we kill the application
    jz i apoptosis ; "kill the program"

    cmp ri r7, 0b0011 ; syscall / works so far
    jz i handle_syscall


    cmp ri r7, 0b0100 ; IllegalInstruction, should kill the program
    
    jz i apoptosis

    cmp ri r7, 0b0101 ; illegal mem access, just kill the program
    
    jz i apoptosis




    hlt




resume_prog_sys:
    ; let's move r0, r1, and r2 onto the heap so we can restore them later:
    mov mr 0x1800, r0
    ; mov mr 0x1801, r1
    ; mov mr 0x1802, r2
    ; good so far

    ; now let's set r0 to prog_idx * 0x19
    mov rm r0, 0x12C8
    mul ri r0, 0x19

    mov ri r1, hi(0x1300)
    mov ri r2, lo(0x1300)
    add rr r2, r0

    ssp m r1


    ; the last thing we need to do with the registers is to push the UPC (big-endian)
    mov ri r1, hi(0x130F)
    mov ri r2, lo(0x130F)
    add rr r2, r0

    push m r1 ; hi byte
    add ri r2, 1
    push m r1 ; lo byte
    
    ; now let's return the registers:
    mov rm r0, 0x1800
    ; mov rm r1, 0x1801
    ; mov rm r2, 0x1802

    ; load user regs
    call i load_uregs_after_syscall


    kret


handle_syscall:

    call i load_syscall_regs ; get registers saved from user, but only those relevant to the syscall

    cmp ri r0, 0 ; no syscall, just return

    jz i kernel


    cmp ri r0, 1 ; see if there's a new input, if so return it

    jz i get_key


    cmp ri r0, 2 ; turn on pixel with x = r1 and y = r2 ; turns to 33%

    jz i pixel_on_33

    cmp ri r0, 3 ; turn off pixel with x = r1 and y = r2
    jz i pixel_off

    cmp ri r0, 4 ; write letter at (x: r1, y: r2) specified by r3
    jz i write_letter

    cmp ri r0, 5 ; change to waiting for input (input "mode" specified in r3)
    jz i set_waiting_input

    cmp ri r0, 6 ; write letter at (x: r1, y: r2) specified by r3, but DON'T override the preexisting letter
    jz i write_letter_in_place

    cmp ri r0, 7 ; pixel on 66%
    jz i pixel_on_66

    cmp ri r0, 8 ; pixel on full
    jz i pixel_on_full

    
    jmp i resume_prog_sys


set_waiting_input:
    mov rm r5, 0x12C8
    mul ri r5, 0x19

    mov ri r6, hi(0x130E) ; byte specifying runnable state; set to 2
    mov ri r7, lo(0x130E)
    
    add rr r7, r5
    ; input mode specified in r3

    mov ri r4, 2 ; "waiting" runnable state
    mov mr r6, r4 ; set to waiting state

    mov ri r6, hi(0x1311) ; byte detailing waiting reason
    mov ri r7, lo(0x1311)
    add rr r7, r5

    push r r0
    mov ri r0, 1
    mov mr r6, r0 ; later will add multiple waiting modes
    pop r r0

    ; have already saved everything, but we probably want to go to the next program in the scheduler:
    jmp i kernel




get_key:
    ; call i poll_input
    mov rm r0, 0x17FF

    ; push r r0
    ; mov ri r0, 0
    ; mov mr 0x17FF, r0
    ; pop r r0
    ; now we're done w/ the syscall so jump to 
    jmp i resume_prog_sys
;


apoptosis:

    mov ri r1, hi(0x130E)
    mov ri r2, lo(0x130E)
    mov ri r0, 0x12C8
    mul ri r0, 0x19

    add rr r2, r0

    mov ri r4, 0 ; later will set to 3, which indicates it should be cleanly disposed of by the kernel
    mov mr r1, r4

    jmp i kernel









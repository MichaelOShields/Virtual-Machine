.org 0x400



kernel: ; round-robin scheduler

    call i load_kregs ; works
    ; poll events
    call i poll_input ; works


    ; main kernel code before returning to prog

    ; to run userprog, store kernel regs, store kernel stack ptr, set/pop user program stack ptr, run user program

    call i save_kregs



    ; pick next program:
    ; start w/ current task index:

    mov rm r0, 0x1260                               ; current task index stored in mem
    mov ri r4, hi(0x130E)                               ; user program #0 state/starting point to search
    mov ri r5, lo(0x130E)

    mov ri r3, 0x19                                 ; # bytes between programs; 0x19 * task_index gives us the task_index program state

    mul ri r3, r0 ; 0x19 * task_index gives us the task_index program state

    call i inc_r5_by_r3 ; jump forwards by # of bytes to get to current task index

    scheduler_loop:                     ; loop until we find a program that wants to run

        mov ri r3, 0x19
        call i inc_r5_by_r3

        mov rm r7, r4 ; check status of program
        cmp ri r7, 0
        jz i scheduler_loop

        cmp ri r7, 1
        jz i found_program

        jmp i scheduler_loop ; need to cover more program states later, but this will do for now
    

    ; we've found a program that should be run:
    found_program:

    ; open up program: 
    

    gsp i 0x1250 ; save KSP


    ; set usp

    ssp m 0x1300 ; should work, doesn't push/pop so i think stack is safe


    ; load user regs
    call i load_uregs


    ; push user program ctr
    push m 0x130A ; big endian
    push m 0x130B

    ;dbg i 0

    ;pnk

    kret


    hlt




; functions:

inc_r4:
    add ri r4, 1
    ret

inc_r5_by_r3:
    add rr r5, r3
    jc i inc_r4
    ret



halt:
    hlt

no_input:
    mov ri r2, 0
    mov mr 0x87FF, r2 ; key hasn't been pressed so we want to record that
    ret


poll_input:
    mov rm r2, 0x3400
    cmp ri r2, 1
    jz i update_input_buffer ; only if a new key's been pressed/is in the deque
    jnz i no_input

    ret


update_input_buffer: ; last input stored at 0x12C4


    mov rm r2, 0x3401

    ; check if its esc
    cmp ri r2, 52
    jz i halt

    ; otherwise continue

    mov mr 0x87FF, r2 ; put into mem buffer

    ; moved last input to 0x12C4
    ret



clear_regs:

    mov ri r0, 0
    mov ri r1, 0
    mov ri r2, 0
    mov ri r3, 0
    mov ri r4, 0
    mov ri r5, 0
    mov ri r6, 0
    mov ri r7, 0

    ret


load_kregs:
    
    mov rm r0, 0x1252 ; works
    mov rm r1, 0x1253
    mov rm r2, 0x1254
    mov rm r3, 0x1255
    mov rm r4, 0x1256
    mov rm r5, 0x1257
    mov rm r6, 0x1258
    mov rm r7, 0x1259

    ret

save_kregs:

    mov mr 0x1252, r0 ; works
    mov mr 0x1253, r1
    mov mr 0x1254, r2
    mov mr 0x1255, r3
    mov mr 0x1256, r4
    mov mr 0x1257, r5
    mov mr 0x1258, r6
    mov mr 0x1259, r7

    ret


load_syscall_regs: ; just bring back syscall-specific regs

    mov rm r0, 0x1302
    mov rm r1, 0x1303
    mov rm r2, 0x1304
    mov rm r3, 0x1305

    ret

load_uregs_after_syscall:

    mov rm r1, 0x1303
    mov rm r2, 0x1304
    mov rm r3, 0x1305
    mov rm r4, 0x1306
    mov rm r5, 0x1307
    mov rm r6, 0x1308
    mov rm r7, 0x1309

    ret

load_uregs:

    mov rm r0, 0x1302
    mov rm r1, 0x1303
    mov rm r2, 0x1304
    mov rm r3, 0x1305
    mov rm r4, 0x1306
    mov rm r5, 0x1307
    mov rm r6, 0x1308
    mov rm r7, 0x1309

    ret

save_uregs:

    mov mr 0x1302, r0
    mov mr 0x1303, r1
    mov mr 0x1304, r2
    mov mr 0x1305, r3
    mov mr 0x1306, r4
    mov mr 0x1307, r5
    mov mr 0x1308, r6
    mov mr 0x1309, r7

    ret






; KERNEL TRAP:

.org 0x1000 ; kernel trap





ktrap_catch:

    call i save_uregs


    ; upc is in stack

    pop r r0
    pop r r1

    ; store upc
    mov mr 0x130A, r0
    mov mr 0x130B, r1

    gsp i 0x1300 ; save usp

    ssp m 0x1250 ; LOAD KSP

    mov rm r0, 0x125A ; get reason

    ; diagnose cpuexit

    cmp ri r0, 0b0000 ; none, probably do nothing
    jz i resume_prog

    cmp ri r0, 0b0001 ; timer, return control to kernel
    jz i resume_prog


    cmp ri r0, 0b0010 ; halt, since it's a cpu exit we kill the application
    jz i apoptosis ; "kill the program"

    cmp ri r0, 0b0011 ; syscall
    jz i handle_syscall
    ; also, afterwards the jz's shouldn't ret, they should return to the kernel/program

    cmp ri r0, 0b0100 ; IllegalInstruction, should kill the program
    
    jz i apoptosis

    cmp ri r0, 0b0101 ; illegal mem access, just kill the program
    
    jz i apoptosis




    jmp i kernel




resume_prog_sys:
    ; set usp
    ssp m 0x1300

    ; load user regs
    call i load_uregs_after_syscall


    push m 0x130A
    push m 0x130B

    kret


resume_prog:
    ; set usp
    ssp m 0x1300

    ; load user regs
    call i load_uregs

    push m 0x130A
    push m 0x130B

    kret


handle_syscall:

    call i load_syscall_regs ; get registers saved from user, but only those relevant to the syscall

    cmp ri r0, 0 ; no syscall, just return

    jz i resume_prog


    cmp ri r0, 1 ; see if there's a new input, if so return it

    jz i get_key


    cmp ri r0, 2 ; turn on pixel with x = r1 and y = r2

    jz i pixel_on

    cmp ri r0, 3 ; turn off pixel with x = r1 and y = r2

    jz i pixel_off

    cmp ri r0, 4 ; write letter at (x: r1, y: r2) specified by r3
    jz i write_letter

    
    jmp i resume_prog_sys



get_key:
    call i poll_input
    mov rm r0, 0x87FF
    ; now we're done w/ the syscall so jump to 
    jmp i resume_prog_sys



apoptosis:
    dbg i 69
    hlt
    pnk

; PIXEL FUNCTIONS:
; generally assume that x = r1, y = r2
; should call before_pixel_op beforehand (obv)
; should return 1 in r0 if it worked, 0 in r0 if it failed

; universal pixel op functions:

check_pixel_bounds: ; make sure we aren't doing anything illegal here


    ; compare r1 (x) to 127, jump if greater than to do nothing probably
    cmp ri r1, 128
    jg i failed_pixel_op

    ; same with r2 (y)
    cmp ri r2, 128
    jg i failed_pixel_op

    ret


before_pixel_op:
    call i check_pixel_bounds ; if this fails, it won't return; could that lead to a stack overflow/leak?

    ret



failed_pixel_op:
    ; if this is called, it means that the operation didn't work; hence, there are 2 bytes in the stack that aren't accounted for
    ; later, pop them? maybe

    dbg i 204
    pnk


    mov ri r0, 0 ; signal failed operation
    jmp i resume_prog_sys



; pixel op helper functions (should only be called after before_pixel_op):

; convert from x,y to vram addr:
convert_xy:
    ; assumes x = r1, y = r2
    ; pretty sure my math works out so no jump carries are needed, which should be more performant than just looping and spamming them
    ; will set r1 to high byte, r2 to low byte, puts the x,y pixel byte in r3

    ; move x and y to r4 and r5

    mov rr r4, r1 ; x is in r4 now
    mov rr r5, r2 ; y is in r5 now
    
    ; now initialize high and low byte
    mov ri r1, hi(0x2400) ; vram base pos
    mov ri r2, lo(0x2400)

    ; let's start with y:
    
    ; need to get y * 16, will put it in r6
    mov rr r6, r5
    ; mul ri r6, 16

    ; now, do high += (y * 16) / 8
    div ri r6, 16

    add rr r1, r6

    ; get original Y back for low += (y * 16) % 8
    mov rr r6, r5
    
    mul ri r6, 16

    ; mod ri r6, 8

    add rr r2, r6

    ; now let's do x, which is pretty simple: add x/8 to low byte

    mov rr r6, r4
    div ri r6, 8
    add rr r2, r6


    ; now let's handle r3:
    mov rr r6, r4 ; move x so we can perform ops on it




    

    ; now just do 0b1000_0000 >> (x % 8), then OR that into mem

    mov ri r3, 0b0000_0001

    mod ri r6, 8 ; modulo op, get remainder

    jz i grab_last_byte_bit

    shrw rr r3, r6

    grabbed_bit:


    ret

grab_last_byte_bit: ; this is when we reach a new byte, but need to get the pixel that's just to the left of the leftmost bit
    ; assumes r1:r2 are high and low
    sub ri r2, 1
    mov ri r3, 0b0000_0001
    jmp i grabbed_bit


go_down:
    add ri r2, 16
    jc i inc_r1
    ret

inc_r1:
    add ri r1, 1
    ret

next_letter_line:
    mov rm r7, r4
    mov mr r1, r7
    call i go_down
    add ri r5, 1
    ret


; pixel ops:


write_letter: ; starts at 0x1200; x is r1, y is r2, letter ID is r3
    call i before_pixel_op

    ; in addition to before_pixel_op bound checks:
    ; letters are 5x7, so ensure that they won't write into illegal mem:
    
    ; compare r1 (x) to 127, jump if greater than to do nothing probably
    cmp ri r1, 123  ; 128-5 = 123
    jg i failed_pixel_op

    ; same with r2 (y)
    cmp ri r2, 121 ; 128-7 = 121
    jg i failed_pixel_op

    ; now the main function:

    push r r3 ; save r3 b/c convert_xy tramples it

    ; go 1 line lower
    add ri r2, 1

    call i convert_xy

    pop r r3


    ; start writing:
    mov ri r4, hi(0x1200)
    mov ri r5, lo(0x1200)

    mul ri r3, 7
    add rr r5, r3           ; get ptr aligned w/ correct letter


    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line
    call i next_letter_line

    jmp i resume_prog_sys


pixel_on:

    call i before_pixel_op

    
    
    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel

    
    ; OR operation - only turn on the specific pixel specified by 8 - (x % 8)

    or rm r3, r1 ; get actual pixels in mem & OR them
    

    ; put r7 (final byte) into mem
    mov mr r1, r3


    jmp i resume_prog_sys




pixel_off:

    call i before_pixel_op

    
    
    call i convert_xy
    ; now r1 = high byte, r2 = low byte, x = r4, y = r5, r3 = byte pixel

    
    ; OR operation - only turn on the specific pixel specified by 8 - (x % 8)

    xor rm r3, r1 ; get actual pixels in mem & OR them
    

    ; put r7 (final byte) into mem
    mov mr r1, r3


    jmp i resume_prog_sys











.org 0x5000


; shell setup:
; first row of pixels is off
; 2-8 rows are letters
; 9th row is off
; 10th row is on

; start:
mov ri r1, 1
mov ri r2, 20

mov ri r6, hi(0x5800)
mov ri r7, lo(0x5800) ; current pos in typing buffer

loop_full_row:
    cmp ri r1, 129
    jz i starting

    mov ri r0, 2 ; turn on pixel
    sys

    add ri r1, 1
    jmp i loop_full_row


starting:
    mov ri r1, 1
    mov ri r2, 1
    call i caret
    push r r4
    mov ri r4, 0
    call i set_output
    pop r r4
    jmp i loop

loop:

    mov ri r0, 5 ; waiting for input
    sys

    call i check_key


    jmp i loop ; do nothing for now


no_key:
    ret

check_key:



    mov ri r0, 1 ; check key syscall id
    sys
    
    cmp ri r0, 0
    jz i no_key

    cmp ri r0, 51
    jz i enter

    cmp ri r0, 50
    jz i backspace

    cmp ri r0, 53
    jz i space

    cmp ri r0, 26
    jl i write_letter
    jz i write_letter

    ret
;


upper_bound_x:
    mov ri r1, 121
    mov ri r7, lo(0x580F)
    ; call i endcaret

    ; since at end of line:
    call i set_at_end

    ret

lower_bound_x:
    mov ri r1, 1
    mov ri r7, lo(0x5800)
    call i caret

    call i unset_at_end

    ret


go_forward:

    add ri r7, 1

    add ri r1, 8

    cmp ri r1, 121
    jg i upper_bound_x

    call i caret
    ret


go_backward:

    sub ri r7, 1

    sub ri r1, 8

    cmp ri r1, 128
    jg i lower_bound_x

    call i caret
    ret

write_letter:

    call i all_chars
    
    mov rr r3, r0

    mov ri r0, 4
    sys

    call i go_forward

    ret
;
    


space:

    call i all_chars

    mov ri r3, 0 ; space

    mov ri r0, 4
    sys

    call i go_forward

    ret
;


empty_current_letter:
    mov ri r3, 0 ; space


    mov ri r0, 4
    sys

    ; call i go_forward

    ret



caret:
    
    mov ri r3, symbol_caret

    mov ri r0, 6 ; in-place letter
    sys

    ; call i go_forward
    ret

endcaret:
    mov ri r3, symbol_endcaret
    mov ri r0, 6 ; in-place letter
    sys

    ret


backspace:

    push r r0
    mov ri r0, 0
    cmp mr 0x5820, r0 ; see if we're at the end; if so, we can call the end sequence backspace:
    pop r r0
    jnz i end_sequence

    call i empty_current_letter
    call i go_backward
    call i empty_current_letter
    call i caret

    ret

    end_sequence:
    ; call i go_backward
    call i empty_current_letter
    call i caret

    ; since not at the end anymore:
    call i unset_at_end

    ret

all_chars:
    mov mr r6, r0
    ret

enter:

    ; handle command
    call i full_check_shutdown
    call i full_check_panic
    call i full_check_test
    
    ; if failed, display failed:
    cmp ri r4, 1
    
    ret


failed_check:
    mov ri r4, 1
    call i set_output
    ret

full_check_shutdown:
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    call i check_shutdown
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    ret

full_check_panic:
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    call i check_panic
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    ret

full_check_test:
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    call i check_test
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    ret

;

check_shutdown:

    mov ri r4, hi(0x5800) ; text buffer
    mov ri r5, lo(0x5800)

    mov ri r6, hi(0x5821) ; shutdown string
    mov ri r7, lo(0x5821)

    jmp i ch_shutdown_loop

    ch_shutdown_loop:
        mov ri r3, 255
        cmp mr r6, r3
        jz i command_shutdown

        mov rm r3, r6
        cmp mr r4, r3
        jnz i failed_check

        add ri r5, 1
        add ri r7, 1
        jmp i ch_shutdown_loop

    ret

check_panic:

    mov ri r4, hi(0x5800) ; text buffer
    mov ri r5, lo(0x5800)

    mov ri r6, hi(0x582B)
    mov ri r7, lo(0x582B)

    jmp i ch_panic_loop

    ch_panic_loop:
        mov ri r3, 255
        cmp mr r6, r3
        jz i command_panic

        mov rm r3, r6
        cmp mr r4, r3
        jnz i failed_check

        add ri r5, 1
        add ri r7, 1
        jmp i ch_panic_loop

    ret

check_test:

    mov ri r4, hi(0x5800) ; text buffer
    mov ri r5, lo(0x5800)

    mov ri r6, hi(0x5840)
    mov ri r7, lo(0x5840)

    jmp i ch_test_loop

    ch_test_loop:
        mov ri r3, 255
        cmp mr r6, r3
        jz i command_test

        mov rm r3, r6
        cmp mr r4, r3
        jnz i failed_check

        add ri r5, 1
        add ri r7, 1
        jmp i ch_test_loop

    ret


command_panic:
    mov ri r4, 3
    call i set_output
    pnk

command_test:
    mov ri r4, 4
    call i set_output
    ret

command_shutdown:
    mov ri r4, 2
    call i set_output
    hlt
    ret
    
render_output:
    push r r0
    push r r1
    push r r2
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    
    mov ri r1, 1
    mov ri r2, 10

    mov ri r3, symbol_x ; placeholder error vals
    
    mov ri r4, hi(0x5810)
    mov ri r5, lo(0x5810)

    mov ri r6, 0x1F ; limit of low byte

    jmp i output_loop

    output_loop:
        ; check if current low byte is > 0x1F, if so return:
        cmp rr r5, r6
        jg i after_writing

        ; if not:
        ; render current letter:

        mov rm r3, r4
        mov ri r0, 4
        sys
        ; increment x & low byte:
        add ri r1, 8
        add ri r5, 1
        jmp i output_loop

    after_writing:
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    pop r r2
    pop r r1
    pop r r0
    ret
    


set_output: ; r4 is ID/idx of msg/output
    push r r2
    push r r3
    push r r6
    push r r7

    mov ri r3, hi(0x5900)
    mul ri r4, 16

    dbg r r4

    mov ri r7, 0

    mov ri r5, hi(0x5810)
    mov ri r6, lo(0x5810)

    set_output_loop:

        cmp ri r7, 0x10
        jz i done

        mov rm r2, r3
        mov mr r5, r2

        add ri r7, 1
        add ri r6, 1
        add ri r4, 1
        jmp i set_output_loop


    done:
    pop r r7
    pop r r6
    pop r r3
    pop r r2
    call i render_output
    ret


set_at_end:
    push r r0

    mov ri r0, 1
    
    mov mr 0x5820, r0

    pop r r0
    ret

unset_at_end:
    push r r0

    mov ri r0, 0
    
    mov mr 0x5820, r0

    pop r r0
    ret

; consts:
.const "symbol_space", 0

.const "symbol_a", 1
.const "symbol_b", 2
.const "symbol_c", 3
.const "symbol_d", 4
.const "symbol_e", 5
.const "symbol_f", 6
.const "symbol_g", 7
.const "symbol_h", 8
.const "symbol_i", 9
.const "symbol_j", 10
.const "symbol_k", 11
.const "symbol_l", 12
.const "symbol_m", 13
.const "symbol_n", 14
.const "symbol_o", 15
.const "symbol_p", 16
.const "symbol_q", 17
.const "symbol_r", 18
.const "symbol_s", 19
.const "symbol_t", 20
.const "symbol_u", 21
.const "symbol_v", 22
.const "symbol_w", 23
.const "symbol_x", 24
.const "symbol_y", 25
.const "symbol_z", 26

.const "symbol_caret", 27
.const "symbol_endcaret", 28

.org 0x5800 ; 0x5800-0x580F are reserved for the typing buffer (only 15 letters fit on the screen, so that's the max)
.byte 0


.org 0x5810 ; 0x5810-0x581F are reserved for the output buffer
.byte 0


.org 0x5820 ; 0x5820 is reserved for the "at-end-of-line" boolean
.byte 0


; commands start at 0x5821
.org 0x5821 ; shutdown
.str "shutdown"

.byte 255

.org 0x582B ; panic
.str "panic"
.byte 255

.org 0x5833 ; spawn
.str "spawn"
.byte 255

.org 0x583B ; kill
.str "kill"
.byte 255

.org 0x5840 ; test
.str "test"
.byte 255


.org 0x5900 ; pre-written output strings. starts w/ check failed
.str "default   output", 16

.org 0x5910 ; 1
.str "cmd not found", 16

.org 0x5920 ; 2
.str "shutting down", 16

.org 0x5930 ; 3
.str "panicking", 16

.org 0x5940 ; 4
.str "abcdefghijklmnop", 16

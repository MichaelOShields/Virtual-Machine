.start
; .abs 0x5000


; shell setup:
; first row of pixels is off
; 2-8 rows are letters
; 9th row is off
; 10th row is on

; start:
mov ri r1, 1
mov ri r2, 20

mov ri r6, hi(rel(0x800))
mov ri r7, lo(rel(0x800)) ; current pos in typing buffer

loop_full_row:
    cmp ri r1, 129
    jz i starting

    mov ri r0, 8 ; turn on pixel
    sys

    add ri r1, 1
    jmp i loop_full_row

; full_column:
;     mov ri r1, 20
;     mov ri r2, 1

; loop_full_column:
;     cmp ri r2, 128
;     jz i starting

;     mov ri r0, 8 ; turn on pixel
;     sys

;     add ri r2, 1
;     jmp i loop_full_column

starting:
    mov ri r1, 1
    mov ri r2, 1
    call i caret
    push r r4
    mov ri r4, 0
    call i set_output
    pop r r4
    jmp i loop

loop:

    mov ri r0, 5 ; waiting for input
    sys

    call i check_key


    jmp i loop ; do nothing for now


no_key:
    ret

check_key:



    mov ri r0, 1 ; check key syscall id
    sys
    
    cmp ri r0, 0
    jz i no_key

    cmp ri r0, 54 ; tab
    jz i toggle_foc


    ; otherwise, let's make sure we're in focus:
    push r r0
    mov ri r0, 0
    cmp mr rel(0x9FF), r0 ; jz means we aren't focused
    pop r r0
    jz i no_key


    cmp ri r0, 51
    jz i enter

    cmp ri r0, 50
    jz i backspace

    cmp ri r0, 53
    jz i space

    cmp ri r0, 26
    jl i write_letter
    jz i write_letter

    ret
;


upper_bound_x:
    mov ri r1, 121
    mov ri r7, lo(rel(0x80F))
    ; call i endcaret

    ; since at end of line:
    call i set_at_end

    ret

lower_bound_x:
    mov ri r1, 1
    mov ri r7, lo(rel(0x800))
    call i caret

    call i unset_at_end

    ret


go_forward:

    add ri r7, 1

    add ri r1, 8

    cmp ri r1, 121
    jg i upper_bound_x

    call i caret
    ret


go_backward:

    sub ri r7, 1

    sub ri r1, 8

    cmp ri r1, 128
    jg i lower_bound_x

    call i caret
    ret

write_letter:

    call i all_chars
    
    mov rr r3, r0

    mov ri r0, 4
    sys

    call i go_forward

    ret
;
    


space:

    call i all_chars

    mov ri r3, 0 ; space

    mov ri r0, 4
    sys

    call i go_forward

    ret
;


empty_current_letter:
    mov ri r3, 0 ; space


    mov ri r0, 4
    sys

    ; call i go_forward

    ret



caret:
    
    mov ri r3, symbol_caret

    mov ri r0, 6 ; in-place letter
    sys

    ; call i go_forward
    ret

endcaret:
    mov ri r3, symbol_endcaret
    mov ri r0, 6 ; in-place letter
    sys

    ret


backspace:



    push r r0
    mov ri r0, 0
    cmp mr rel(0x820), r0 ; see if we're at the end; if so, we can call the end sequence backspace:
    pop r r0
    jnz i end_sequence

    call i empty_current_letter
    call i go_backward
    call i empty_current_letter
    call i caret

    call i all_chars

    ret

    end_sequence:
    ; call i go_backward
    call i empty_current_letter
    call i caret

    ; since not at the end anymore:
    call i unset_at_end

    ret

all_chars:
    mov mr r6, r0
    ret

enter:

    ; handle command
    call i full_check_shutdown
    call i full_check_panic
    call i full_check_test
    
    ; if failed, display failed:
    cmp ri r4, 1
    
    ret


failed_check:
    mov ri r4, 1
    call i set_output
    ret

full_check_shutdown:
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    call i check_shutdown
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    ret

full_check_panic:
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    call i check_panic
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    ret

full_check_test:
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    call i check_test
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    ret

;

check_shutdown:

    mov ri r4, hi(rel(0x800)) ; text buffer
    mov ri r5, lo(rel(0x800))

    mov ri r6, hi(rel(0x821)) ; shutdown string
    mov ri r7, lo(rel(0x821))

    jmp i ch_shutdown_loop

    ch_shutdown_loop:
        mov ri r3, 255
        cmp mr r6, r3
        jz i command_shutdown

        mov rm r3, r6
        cmp mr r4, r3
        jnz i failed_check

        add ri r5, 1
        add ri r7, 1
        jmp i ch_shutdown_loop

    ret

check_panic:

    mov ri r4, hi(rel(0x800)) ; text buffer
    mov ri r5, lo(rel(0x800))

    mov ri r6, hi(rel(0x82B))
    mov ri r7, lo(rel(0x82B))

    jmp i ch_panic_loop

    ch_panic_loop:
        mov ri r3, 255
        cmp mr r6, r3
        jz i command_panic

        mov rm r3, r6
        cmp mr r4, r3
        jnz i failed_check

        add ri r5, 1
        add ri r7, 1
        jmp i ch_panic_loop

    ret

check_test:

    mov ri r4, hi(rel(0x800)) ; text buffer
    mov ri r5, lo(rel(0x800))

    mov ri r6, hi(rel(0x840))
    mov ri r7, lo(rel(0x840))

    jmp i ch_test_loop

    ch_test_loop:
        mov ri r3, 255
        cmp mr r6, r3
        jz i command_test

        mov rm r3, r6
        cmp mr r4, r3
        jnz i failed_check

        add ri r5, 1
        add ri r7, 1
        jmp i ch_test_loop

    ret


command_panic:
    mov ri r4, 3
    call i set_output
    pnk

command_test:
    mov ri r4, 4
    call i set_output
    ret

command_shutdown:
    mov ri r4, 2
    call i set_output
    hlt
    ret
;

draw_line: ; assumes r0 is either 2 (33%), 3 (off), 7 (66%), or 8 (100%)
    push r r1
    push r r2
    mov ri r1, 1
    mov ri r2, 20
    line_loop:
        cmp ri r1, 129
        jz i done_drawing

        sys

        add ri r1, 1
        jmp i line_loop
    

    done_drawing:
    pop r r2
    pop r r1
    ret


unfocus:

    mov ri r0, 2
    call i draw_line

    mov ri r0, 0
    mov mr rel(0x9FF), r0

    ret

focus:
    mov ri r0, 8 ; 33%
    call i draw_line
    mov ri r0, 1
    mov mr rel(0x9FF), r0
    ret

toggle_foc:
    mov ri r5, 1 ; "focused"
    cmp mr rel(0x9FF), r5
    jz i unfocus
    jnz i focus
    ret

render_output:
    push r r0
    push r r1
    push r r2
    push r r3
    push r r4
    push r r5
    push r r6
    push r r7
    
    mov ri r1, 1
    mov ri r2, 10

    mov ri r3, symbol_x ; placeholder error vals
    
    mov ri r4, hi(rel(0x810))
    mov ri r5, lo(rel(0x810))

    mov ri r6, 0x1F ; limit of low byte

    jmp i output_loop

    output_loop:
        ; check if current low byte is > 0x1F, if so return:
        cmp rr r5, r6
        jg i after_writing

        ; if not:
        ; render current letter:

        mov rm r3, r4
        mov ri r0, 4
        sys
        ; increment x & low byte:
        add ri r1, 8
        add ri r5, 1
        jmp i output_loop

    after_writing:
    pop r r7
    pop r r6
    pop r r5
    pop r r4
    pop r r3
    pop r r2
    pop r r1
    pop r r0
    ret
    


set_output: ; r4 is ID/idx of msg/output
    push r r2
    push r r3
    push r r6
    push r r7

    mov ri r3, hi(rel(0x900))
    mul ri r4, 16

    ; dbg r r4

    mov ri r7, 0

    mov ri r5, hi(rel(0x810))
    mov ri r6, lo(rel(0x810))

    set_output_loop:

        cmp ri r7, 0x10
        jz i done

        mov rm r2, r3
        mov mr r5, r2

        add ri r7, 1
        add ri r6, 1
        add ri r4, 1
        jmp i set_output_loop


    done:
    pop r r7
    pop r r6
    pop r r3
    pop r r2
    call i render_output
    ret


set_at_end:
    push r r0

    mov ri r0, 1
    
    mov mr rel(0x820), r0

    pop r r0
    ret

unset_at_end:
    push r r0

    mov ri r0, 0
    
    mov mr rel(0x820), r0

    pop r r0
    ret

; consts:
.const "symbol_space", 0

.const "symbol_a", 1
.const "symbol_b", 2
.const "symbol_c", 3
.const "symbol_d", 4
.const "symbol_e", 5
.const "symbol_f", 6
.const "symbol_g", 7
.const "symbol_h", 8
.const "symbol_i", 9
.const "symbol_j", 10
.const "symbol_k", 11
.const "symbol_l", 12
.const "symbol_m", 13
.const "symbol_n", 14
.const "symbol_o", 15
.const "symbol_p", 16
.const "symbol_q", 17
.const "symbol_r", 18
.const "symbol_s", 19
.const "symbol_t", 20
.const "symbol_u", 21
.const "symbol_v", 22
.const "symbol_w", 23
.const "symbol_x", 24
.const "symbol_y", 25
.const "symbol_z", 26

.const "symbol_caret", 27
.const "symbol_endcaret", 28

.rel 0x800 ; 0x5800-0x580F are reserved for the typing buffer (only 15 letters fit on the screen, so that's the max)
.byte 0


.rel 0x810 ; 0x5810-0x581F are reserved for the output buffer
.byte 0


.rel 0x820 ; 0x5820 is reserved for the "at-end-of-line" boolean
.byte 0



; commands start at 0x821 (was 0x5821)
.rel 0x821 ; shutdown
.str "shutdown"
.byte 255

.rel 0x82B ; panic (was 0x582B)
.str "panic"
.byte 255

.rel 0x833 ; spawn (was 0x5833)
.str "spawn"
.byte 255

.rel 0x83B ; kill (was 0x583B)
.str "kill"
.byte 255

.rel 0x840 ; test (was 0x5840)
.str "test"
.byte 255


.rel 0x900 ; pre-written output strings. starts w/ check failed (was 0x5900)
.str "default   output", 16

.rel 0x910 ; 1 (was 0x5910)
.str "cmd not found", 16

.rel 0x920 ; 2 (was 0x5920)
.str "halting shell", 16

.rel 0x930 ; 3 (was 0x5930)
.str "panicking", 16

.rel 0x940 ; 4 (was 0x5940)
.str "abcdefghijklmnop", 16

.rel 0x9FF ; "focused" boolean (was 0x59FF)
.byte 1